shapeless : An exploration of generic/polytypic programming in Scala
====================================================================

shapeless is an exploration of generic (aka polytypic) programming in Scala
derived from the various talks I (Miles Sabin) have given over the course
of 2011 on implementing [Scrap your boilerplate](http://goo.gl/KmfVG) and
[higher rank polymorphism](http://goo.gl/zGRQ7) in Scala.

In the new year I'll be [posting](http://www.chuusai.com/blog) a (long
overdue) series of articles on the implementation techniques used: heavily 
type class based, with essential use of dependent types at various
junctures, which together enable the relatively smooth encoding of type level
functions. In the meantime you'll find Olivera, Moors and Odersky [Type
Classes as Object and Implicits](http://goo.gl/ZbcxY) useful background
material.

In more concrete terms, selected highlights include,

* A new encoding of polymorphic function values which optionally supports
  type specific cases, and which is interoperable with Scala's ordinary
  monomorphic function values.

* A `Typeable` type class which provides a type safe cast operation. 

* The mother of all Scala `HLists`, which amongst other things,
    * is covariant.
    * covers the territory of both typical `HLists` and also `KLists`
      (`HLists` whose elements share a common outer type constructor).
    * has a map operation, applying a polymorphic function value (possibly
      with type specific cases) across its elements.
    * has a zipper for traversal and persistent update.
    * has a `unify` operation which converts it to an `HList` of elements
      of the least upper bound of the original types.
    * supports conversion to an ordinary Scala `List` of elements of the
      least upper bound of the original types.
    * has a `Typeable` type class instance, allowing, eg. vanilla
      `List[Any]`s or `HLists` with elements of type `Any` to be safely
      cast to precisely typed `HLists`.
      
* Conversions between tuples and `HLists`, and between ordinary Scala
  functions of arbitrary arity and functions which take a single
  corresponding `HList` argument. One application of this is the `liftO`
  function which lifts an ordinary function of arbitrary arity into `Option`. 
      
The last three bullets under `HList` make them dramatically more practically
useful than they are typically thought to be: normally the full type
information required to work with them is too fragile to cross subtyping or
I/O boundaries. This new `HList` implementation supports the discarding of
precise information where necessary (eg. to serialize a precisely typed
record after construction), and its later reconstruction (eg. a weakly
typed deserialized record with a known schema can have it's precise typing
reestabilished).

The library is targetted at Scala 2.10-SNAPSHOT by default, but currently
should build against Scala 2.9.1.final with the `-Ydependent-method-types`
switch enabled. I make no promises that it'll continue to build with 2.9.x,
or even vanilla Scala 2.10-SNAPSHOT: in 2012 I plan to investigate, amongst
other things, what can be done with [singleton types for literal values]
(http://goo.gl/U18kK) ... at a minimum they would make the clunky encoding
of type level natural numbers (in `shapeless/nat.scala`) redundant, and
might enable a whole lot more.

Building
--------

shapeless is built using sbt. On Linux and Mac OS run the `sbt` script and
perform the `compile` task.

Eclipse project metadata can be generated by performing the `eclipse` task.
If you're working with Eclipse I recommend using the [nightly builds
relative to Scala master](http://goo.gl/iRgyc).

Testing
-------

shapeless comes with a collection of JUnit tests which exercise most of its
features. To run, perform the sbt `test` task.
